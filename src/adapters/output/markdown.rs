use anyhow::Result;
use chrono::Local;
use std::collections::BTreeMap;
use std::io::Write;
use std::path::Path;

use crate::core::config::ContextConfig;
use crate::core::content::{minify_content, ContentType, FileContext};
use crate::ports::writer::ContextWriter;

#[derive(Default)]
struct TreeNode {
    children: BTreeMap<String, TreeNode>,
}

impl TreeNode {
    fn insert(&mut self, path: &Path) {
        let mut current = self;
        for component in path.components() {
            let key = component.as_os_str().to_string_lossy().to_string();
            current = current.children.entry(key).or_default();
        }
    }

    fn render(&self, prefix: &str, buffer: &mut String) {
        let count = self.children.len();
        for (i, (name, node)) in self.children.iter().enumerate() {
            let is_last = i == count - 1;
            let connector = if is_last { "└── " } else { "├── " };

            buffer.push_str(&format!("{}{}{}\n", prefix, connector, name));

            let new_prefix = if is_last {
                format!("{}    ", prefix)
            } else {
                format!("{}│   ", prefix)
            };

            node.render(&new_prefix, buffer);
        }
    }
}

#[derive(Default)]
pub struct MarkdownWriter;

impl MarkdownWriter {
    pub fn new() -> Self {
        Self
    }

    fn generate_tree(&self, files: &[FileContext], root_name: &str) -> String {
        let mut root = TreeNode::default();
        for file in files {
            root.insert(&file.relative_path);
        }

        let mut output = String::new();
        output.push_str(&format!("{}\n", root_name));
        root.render("", &mut output);
        output
    }
}

impl ContextWriter for MarkdownWriter {
    fn write<W: Write>(
        &self,
        files: &[FileContext],
        config: &ContextConfig,
        mut writer: W,
    ) -> Result<()> {
        writeln!(writer, "# Project Context Report")?;
        writeln!(
            writer,
            "> Generated by Context Engine on {}\n",
            Local::now().format("%Y-%m-%d %H:%M:%S")
        )?;

        writeln!(writer, "## Metadata")?;
        writeln!(writer, "- **Root:** `{}`", config.root_path.display())?;
        writeln!(writer, "- **Files:** {}", files.len())?;

        let total_tokens: usize = files.iter().map(|f| f.token_count).sum();
        writeln!(writer, "- **Tokens (Est.):** {}\n", total_tokens)?;

        writeln!(writer, "## Project Structure")?;
        let root_name = config
            .root_path
            .file_name()
            .map(|n| n.to_string_lossy())
            .unwrap_or_else(|| ".".into());

        writeln!(writer, "```text")?;
        writeln!(
            writer,
            "{}",
            self.generate_tree(files, &root_name).trim_end()
        )?;
        writeln!(writer, "```\n")?;

        writeln!(writer, "## File Contents")?;

        for file in files {
            writeln!(writer, "### `{}`", file.relative_path.display())?;

            match &file.content {
                ContentType::Text(text) => {
                    let processed = if config.minify {
                        minify_content(text)
                    } else {
                        text.to_string()
                    };

                    writeln!(writer, "```{}", file.language)?;
                    writeln!(writer, "{}", processed)?;
                    writeln!(writer, "```\n")?;
                }
                ContentType::Binary => {
                    writeln!(writer, "> *[Binary Content Skipped]*\n")?;
                }
                ContentType::Error(e) => {
                    writeln!(writer, "> *[Error reading file: {}]*\n", e)?;
                }
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_markdown_output_structure() {
        let config = ContextConfig::default();
        let files = vec![FileContext::new(
            PathBuf::from("src/main.rs"),
            PathBuf::from("src/main.rs"),
            ContentType::Text("fn main() {}".into()),
            "rust".into(),
            10,
        )];

        let writer = MarkdownWriter::new();
        let mut buffer = Vec::new();

        writer
            .write(&files, &config, &mut buffer)
            .expect("Should write Markdown");
        let output = String::from_utf8(buffer).expect("Valid UTF-8");

        assert!(output.contains("# Project Context Report"));
        assert!(output.contains("## Project Structure"));
        assert!(output.contains("```rust"));
        assert!(output.contains("fn main() {}"));
        assert!(output.contains("```"));
    }
}
